package pineapple

import (
	"encoding/binary"
	"io"
	"log"
	"time"

	"pineapple/fastrpc"
	"pineapple/genericsmr"
	"pineapple/genericsmrproto"
	"pineapple/pineappleproto"
	"pineapple/state"
)

const CLOCK = 1000 * 10
const CHAN_BUFFER_SIZE = 200000
const TRUE = uint8(1)
const FALSE = uint8(0)

type InstanceStatus int

const (
	PREPARING InstanceStatus = iota
	PREPARED
	ACCEPTED
	COMMITTED
)

// Replica Node: performs ABD operations on single read write, and Paxos on multi read write and RMW
type Replica struct {
	*genericsmr.Replica // extends a generic Paxos replica

	// ABD
	getChan      chan fastrpc.Serializable
	setChan      chan fastrpc.Serializable
	getReplyChan chan fastrpc.Serializable
	setReplyChan chan fastrpc.Serializable
	getRPC       uint8
	setRPC       uint8
	getReplyRPC  uint8
	setReplyRPC  uint8

	// Paxos
	prepareChan      chan fastrpc.Serializable
	prepareReplyChan chan fastrpc.Serializable
	rmwGetChan       chan fastrpc.Serializable
	rmwGetReplyChan  chan fastrpc.Serializable
	rmwSetChan       chan fastrpc.Serializable
	rmwSetReplyChan  chan fastrpc.Serializable
	commitChan       chan fastrpc.Serializable
	commitShortChan  chan fastrpc.Serializable
	prepareRPC       uint8
	prepareReplyRPC  uint8
	rmwGetRPC        uint8
	rmwGetReplyRPC   uint8
	rmwSetRPC        uint8
	rmwSetReplyRPC   uint8
	commitRPC        uint8
	commitShortRPC   uint8

	IsLeader bool // does this replica think it is the leader
	Shutdown bool
	data     map[int]pineappleproto.Payload
	// prev // value & carstamp generated by previously executed RMWs
	instanceSpace []*Instance // the space of all instances (used and not yet used)
	defaultBallot int32       // default ballot for new instances (0 until a Prepare(ballot, instance->infinity) from a leader)
	crtInstance   int32       // highest used instance number that this replica knows about

	flush         bool
	committedUpTo int32
}

type Instance struct {
	cmds         []state.Command
	receivedRMW  pineappleproto.Payload
	receivedData []pineappleproto.Payload
	ballot       int32
	status       InstanceStatus
	lb           *LeaderBookkeeping
}

type LeaderBookkeeping struct {
	clientProposals []*genericsmr.Propose
	maxRecvBallot   int32
	getOKs          int
	setOKs          int
	getDone         bool // has get phase been completed
	prepareOKs      int
	rmwGetOKs       int
	rmwSetOKs       int
	rmwGetDone      bool // has rmwGet phase been completed
	nacks           int
	completed       bool
}

func NewReplica(id int, peerAddrList []string, exec bool, dreply bool) *Replica {
	// extends a normal replica
	r := &Replica{
		genericsmr.NewReplica(id, peerAddrList, exec, dreply),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, 3*CHAN_BUFFER_SIZE),
		0,
		0,
		0,
		0,
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		make(chan fastrpc.Serializable, CHAN_BUFFER_SIZE),
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,

		false,
		false,
		map[int]pineappleproto.Payload{},
		make([]*Instance, 20*1024*1024),
		0,
		0,

		false,
		0,
	}

	// ABD
	r.getRPC = r.RegisterRPC(new(pineappleproto.Get), r.getChan)
	r.setRPC = r.RegisterRPC(new(pineappleproto.Set), r.setChan)
	r.getReplyRPC = r.RegisterRPC(new(pineappleproto.GetReply), r.getReplyChan)
	r.setReplyRPC = r.RegisterRPC(new(pineappleproto.SetReply), r.setReplyChan)

	// Paxos
	r.prepareRPC = r.RegisterRPC(new(pineappleproto.Prepare), r.prepareChan)
	r.prepareReplyRPC = r.RegisterRPC(new(pineappleproto.PrepareReply), r.prepareReplyChan)
	r.rmwGetRPC = r.RegisterRPC(new(pineappleproto.RMWGet), r.rmwGetChan)
	r.rmwGetReplyRPC = r.RegisterRPC(new(pineappleproto.RMWGetReply), r.rmwGetReplyChan)
	r.rmwSetRPC = r.RegisterRPC(new(pineappleproto.RMWSet), r.rmwSetChan)
	r.rmwSetReplyRPC = r.RegisterRPC(new(pineappleproto.RMWSetReply), r.rmwSetReplyChan)
	r.commitRPC = r.RegisterRPC(new(pineappleproto.Commit), r.commitChan)
	r.commitShortRPC = r.RegisterRPC(new(pineappleproto.CommitShort), r.commitShortChan)

	go r.Run()

	return r
}

// Compare two tags, returning true if the received tag is larger.
// A tag is larger than another if it has a higher timestamp.
// If both tags have the same timestamp, the tag with the Paxos leader id is smaller
func (r *Replica) isLargerTag(currentTag pineappleproto.Tag, receivedTag pineappleproto.Tag) bool {
	if receivedTag.Timestamp > currentTag.Timestamp {
		return true
	} else if receivedTag.Timestamp == currentTag.Timestamp {
		// if the replica is the leader and the tag has its id, prefer the receivedTag
		if r.IsLeader && currentTag.ID == int(r.Id) {
			return true
		}
	}
	return false
}

func (r *Replica) replyPrepare(replicaId int32, reply *pineappleproto.PrepareReply) {
	r.SendMsg(replicaId, r.prepareReplyRPC, reply)
}

func (r *Replica) replyRMWGet(replicaId int32, reply *pineappleproto.RMWGetReply) {
	r.SendMsg(replicaId, r.rmwGetReplyRPC, reply)
}

func (r *Replica) replyRMWSet(replicaId int32, reply *pineappleproto.RMWSetReply) {
	r.SendMsg(replicaId, r.rmwSetReplyRPC, reply)
}

func (r *Replica) replyGet(replicaId int32, reply *pineappleproto.GetReply) {
	r.SendMsg(replicaId, r.getReplyRPC, reply)
}

func (r *Replica) replySet(replicaId int32, reply *pineappleproto.SetReply) {
	r.SendMsg(replicaId, r.setReplyRPC, reply)
}

// Get Phase (Coordinator)
// Broadcasts query to all replicas to get value-tag pairs
func (r *Replica) bcastGet(instance int32, write bool, key int) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Prepare broadcast failed: ", err)
		}
	}()
	wr := FALSE
	if write {
		wr = TRUE
	}
	args := &pineappleproto.Get{ReplicaID: r.Id, Instance: instance, Write: wr, Key: key}
	replicaCount := r.N - 1
	q := r.Id
	// Send to each connected replica
	for sentCount := 0; sentCount < replicaCount; sentCount++ {
		q = (q + 1) % int32(r.N)
		if q == r.Id {
			break
		}
		if !r.Alive[q] {
			continue
		}

		r.SendMsg(q, r.getRPC, args)
	}
}

// ABD reply to get query
// Returns replica's value-tag pair to requester
func (r *Replica) handleGet(get *pineappleproto.Get) {
	var getReply *pineappleproto.GetReply
	var command state.Command
	ok := TRUE
	data, doesExist := r.data[get.Key]

	// If init or payload is empty, simply return empty payload
	if r.instanceSpace[r.crtInstance] == nil || !doesExist { // TODO: Is this block needed?
		getReply = &pineappleproto.GetReply{Instance: get.Instance, OK: ok, Write: get.Write,
			Key: get.Key, Payload: pineappleproto.Payload{}, // TODO: test removing payload
		}
		r.replyGet(get.ReplicaID, getReply)
		return
	}

	// Return the most recent data held by storage node only if READ, since payload would be overwritten in write
	if get.Write == 0 { // TODO: This was changed to 0, ensure no issues arise
		getReply = &pineappleproto.GetReply{Instance: get.Instance, OK: ok, Write: get.Write,
			Key: get.Key, Payload: data,
		}
		command.Op = 1
	} else { // init with empty payload
		getReply = &pineappleproto.GetReply{Instance: get.Instance, OK: ok, Write: get.Write,
			Key: get.Key, Payload: pineappleproto.Payload{}, // TODO: test removing payload
		}
	}

	/*
		cmds := make([]state.Command, 1)

			if getReply.OK == TRUE {
				r.recordCommands(cmds)
				r.sync()
			}
	*/

	r.replyGet(get.ReplicaID, getReply)
}

// Chooses the most recent vt pair after waiting for majority ACKs (or increment timestamp if write)
func (r *Replica) handleGetReply(getReply *pineappleproto.GetReply) {
	inst := r.instanceSpace[getReply.Instance]
	if inst.lb.getDone { // avoid proceeding to set phase several times
		return
	}

	r.instanceSpace[getReply.Instance].receivedData =
		append(r.instanceSpace[getReply.Instance].receivedData, getReply.Payload)

	// Send the new vt pair to all nodes after getting majority
	if getReply.OK == TRUE {
		inst.lb.getOKs++

		if inst.lb.getOKs+1 > r.N>>1 {
			key := getReply.Key
			identicalCount := 0 // keep track of the count of identical responses
			firstResponse := r.instanceSpace[getReply.Instance].receivedData[0]
			// Find the largest received timestamp
			for _, data := range r.instanceSpace[getReply.Instance].receivedData {
				if r.isLargerTag(r.data[key].Tag, data.Tag) { // received value has larger tag
					r.data[key] = getReply.Payload
				}
				// tracks if all responses are identical by comparing each to the first
				if data.Tag.Timestamp == firstResponse.Tag.Timestamp {
					identicalCount++
				}
			}
			receivedDataCount := len(r.instanceSpace[getReply.Instance].receivedData)
			r.instanceSpace[getReply.Instance].receivedData = nil // clear slice, no longer needed
			inst.lb.getDone = true                                // getPhase completed

			// Optimized read; don't proceed to set if the quorum all has the latest timestamp
			if getReply.Write == 0 &&
				identicalCount == receivedDataCount {
				// respond to client
				if inst.lb.clientProposals != nil && r.Dreply && !inst.lb.completed {
					propreply := &genericsmrproto.ProposeReplyTS{
						OK:        TRUE,
						CommandId: inst.lb.clientProposals[0].CommandId,
						Value:     state.NIL,
						Timestamp: inst.lb.clientProposals[0].Timestamp}
					r.ReplyProposeTS(propreply, inst.lb.clientProposals[0].Reply)
					inst.lb.completed = true
				}
				return
			}

			write := false
			inst.status = PREPARED
			inst.lb.nacks = 0
			// If writing, choose a higher unique timestamp (by adjoining replica ID with Timestamp++)
			if getReply.Write == 1 {
				write = true
				newTag := pineappleproto.Tag{Timestamp: r.data[key].Tag.Timestamp + 1, ID: int(r.Id)}
				r.data[key] = pineappleproto.Payload{Tag: newTag, Value: r.data[key].Value}
			}
			r.sync()
			r.bcastSet(getReply.Instance, write, key, r.data[key])
		}
	}
}

// Set Phase (Coordinator)
// Broadcasts to all replicas to write sent payload
func (r *Replica) bcastSet(instance int32, write bool, key int, payload pineappleproto.Payload) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Prepare bcast failed:", err)
		}
	}()

	wr := FALSE
	if write {
		wr = TRUE
	}
	args := &pineappleproto.Set{ReplicaID: r.Id, Instance: instance, Write: wr,
		Key: key, Payload: payload,
	}

	replicaCount := r.N - 1
	q := r.Id

	// Send to each connected replica
	for sentCount := 0; sentCount < replicaCount; sentCount++ {
		q = (q + 1) % int32(r.N)
		if q == r.Id {
			break
		}
		if !r.Alive[q] {
			continue
		}

		r.SendMsg(q, r.setRPC, args)
	}
}

// ABD Set phase
// Handle set query from coordinator
func (r *Replica) handleSet(set *pineappleproto.Set) {
	var setReply *pineappleproto.SetReply

	// Sets received payload if largest tag seen
	if r.isLargerTag(r.data[set.Key].Tag, set.Payload.Tag) {
		r.data[set.Key] = set.Payload
	}

	setReply = &pineappleproto.SetReply{Instance: set.Instance}

	//r.sync()
	r.replySet(set.ReplicaID, setReply)
}

// Response handler for Set request on nodes
func (r *Replica) handleSetReply(setReply *pineappleproto.SetReply) {
	inst := r.instanceSpace[setReply.Instance]

	inst.lb.setOKs++

	// Wait for a majority of acknowledgements
	if inst.lb.setOKs+1 > r.N>>1 {
		if inst.lb.clientProposals != nil && r.Dreply && !inst.lb.completed {
			propreply := &genericsmrproto.ProposeReplyTS{
				OK:        TRUE,
				CommandId: inst.lb.clientProposals[0].CommandId,
				Value:     state.NIL,
				Timestamp: inst.lb.clientProposals[0].Timestamp}
			r.ReplyProposeTS(propreply, inst.lb.clientProposals[0].Reply)
			inst.lb.completed = true
		}

		//r.sync() //is this necessary?
	}

}

func (r *Replica) bcastPrepare(instance int32, ballot int32, toInfinity bool) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Prepare bcast failed:", err)
		}
	}()
	ti := FALSE
	if toInfinity {
		ti = TRUE
	}
	args := &pineappleproto.Prepare{LeaderId: r.Id, Instance: instance, Ballot: ballot, ToInfinity: ti}

	n := r.N - 1
	q := r.Id

	for sent := 0; sent < n; {
		q = (q + 1) % int32(r.N)
		if q == r.Id {
			break
		}
		if !r.Alive[q] {
			continue
		}
		sent++
		r.SendMsg(q, r.prepareRPC, args)
	}
}

func (r *Replica) handlePrepare(prepare *pineappleproto.Prepare) {
	inst := r.instanceSpace[prepare.Instance]
	var preply *pineappleproto.PrepareReply

	if inst == nil {
		ok := TRUE
		if r.defaultBallot > prepare.Ballot {
			ok = FALSE
		}
		preply = &pineappleproto.PrepareReply{Instance: prepare.Instance, OK: ok,
			Ballot: r.defaultBallot, Command: make([]state.Command, 0)}
	} else {
		ok := TRUE
		if prepare.Ballot < inst.ballot {
			ok = FALSE
		}
		preply = &pineappleproto.PrepareReply{Instance: prepare.Instance, OK: ok,
			Ballot: inst.ballot, Command: inst.cmds}
	}

	r.replyPrepare(prepare.LeaderId, preply)

	if prepare.ToInfinity == TRUE && prepare.Ballot > r.defaultBallot {
		r.defaultBallot = prepare.Ballot
	}
}

func (r *Replica) handlePrepareReply(preply *pineappleproto.PrepareReply) {
	inst := r.instanceSpace[preply.Instance]

	if inst.status != PREPARING {
		// TODO: should replies for non-current ballots be ignored?
		// we've moved on -- these are delayed replies, so just ignore
		return
	}

	if preply.OK == TRUE {
		inst.lb.prepareOKs++

		if preply.Ballot > inst.lb.maxRecvBallot {
			inst.cmds = preply.Command
			inst.lb.maxRecvBallot = preply.Ballot
			if inst.lb.clientProposals != nil {
				// there is already a competing command for this instance,
				// so we put the client proposal back in the queue so that
				// we know to try it in another instance
				for i := 0; i < len(inst.lb.clientProposals); i++ {
					r.ProposeChan <- inst.lb.clientProposals[i]
				}
				inst.lb.clientProposals = nil
			}
		}

		if inst.lb.prepareOKs+1 > r.N>>1 {
			inst.status = PREPARED
			inst.lb.nacks = 0
			if inst.ballot > r.defaultBallot {
				r.defaultBallot = inst.ballot
			}
			r.recordInstanceMetadata(r.instanceSpace[preply.Instance])
			r.sync()
			r.bcastRMWGet(preply.Instance, inst.ballot, inst.cmds)
		}
	} else {
		// TODO: there is probably another active leader
		inst.lb.nacks++
		if preply.Ballot > inst.lb.maxRecvBallot {
			inst.lb.maxRecvBallot = preply.Ballot
		}
		if inst.lb.nacks >= r.N>>1 {
			if inst.lb.clientProposals != nil {
				// try the proposals in another instance
				for i := 0; i < len(inst.lb.clientProposals); i++ {
					r.ProposeChan <- inst.lb.clientProposals[i]
				}
				inst.lb.clientProposals = nil
			}
		}
	}
}

var pRMWGet pineappleproto.RMWGet

func (r *Replica) bcastRMWGet(instance int32, ballot int32, command []state.Command) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Accept bcast failed:", err)
		}
	}()
	pRMWGet.LeaderId = r.Id
	pRMWGet.Instance = instance
	pRMWGet.Ballot = ballot
	pRMWGet.Command = command
	args := &pRMWGet

	n := r.N - 1
	q := r.Id
	for sent := 0; sent < n; {
		q = (q + 1) % int32(r.N)
		if q == r.Id {
			break
		}
		if !r.Alive[q] {
			continue
		}
		sent++
		r.SendMsg(q, r.rmwGetRPC, args)
	}
}

func (r *Replica) handleRMWGet(rmwGet *pineappleproto.RMWGet) {
	inst := r.instanceSpace[rmwGet.Instance]
	key := int(rmwGet.Command[0].K)

	var rmwGetReply *pineappleproto.RMWGetReply

	if inst == nil {
		if rmwGet.Ballot < r.defaultBallot {
			panic("outdated ballot received")
		} else {
			r.instanceSpace[rmwGet.Instance] = &Instance{
				cmds:   rmwGet.Command,
				ballot: rmwGet.Ballot,
				status: ACCEPTED,
				lb:     nil,
			}
			rmwGetReply = &pineappleproto.RMWGetReply{Instance: rmwGet.Instance, Ballot: r.defaultBallot, Key: key}
		}
	} else if rmwGet.Ballot < inst.ballot {
		panic("outdated ballot received")
	} else {
		// reordered ACCEPT
		r.instanceSpace[rmwGet.Instance].cmds = rmwGet.Command
		if r.instanceSpace[rmwGet.Instance].status != COMMITTED {
			r.instanceSpace[rmwGet.Instance].status = ACCEPTED
		}
		data := r.data[key]
		rmwGetReply = &pineappleproto.RMWGetReply{Instance: rmwGet.Instance, Ballot: r.defaultBallot, Key: key, Payload: data}
	}

	r.replyRMWGet(rmwGet.LeaderId, rmwGetReply)
}

// Chooses the most recent vt pair after waiting for majority ACKs (or increment timestamp if write)
func (r *Replica) handleRMWGetReply(rmwGetReply *pineappleproto.RMWGetReply) {
	inst := r.instanceSpace[rmwGetReply.Instance]
	if inst.lb.rmwGetDone { // avoid calling handleRMWSet more than once
		return
	}

	r.instanceSpace[rmwGetReply.Instance].receivedData =
		append(r.instanceSpace[rmwGetReply.Instance].receivedData, rmwGetReply.Payload)

	inst.lb.rmwGetOKs++

	if inst.lb.rmwGetOKs+1 > r.N>>1 { // quorom of messages received
		key := rmwGetReply.Key

		// Find the largest received timestamp
		for _, data := range r.instanceSpace[rmwGetReply.Instance].receivedData {
			if r.isLargerTag(r.data[key].Tag, data.Tag) { // received value has larger tag
				r.data[key] = rmwGetReply.Payload
			}
		}

		r.instanceSpace[rmwGetReply.Instance].receivedData = nil // clear slice, no longer needed
		inst.lb.rmwGetDone = true                                // rmwGet phase completed

		inst.lb.nacks = 0
		// If writing, choose a higher unique timestamp (by adjoining replica ID with Timestamp++)
		newTag := pineappleproto.Tag{Timestamp: r.data[key].Tag.Timestamp + 1, ID: int(r.Id)}
		newValue := r.data[key].Value + 1 // TODO: update RMW modify
		r.data[key] = pineappleproto.Payload{Tag: newTag, Value: newValue}

		r.recordInstanceMetadata(r.instanceSpace[rmwGetReply.Instance])
		r.recordCommands(r.instanceSpace[rmwGetReply.Instance].cmds)
		r.sync()

		r.bcastRMWSet(rmwGetReply.Instance, rmwGetReply.Ballot)
	}
}

var pRMWSet pineappleproto.RMWSet

func (r *Replica) bcastRMWSet(instance int32, ballot int32) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Accept bcast failed:", err)
		}
	}()
	pRMWSet.LeaderId = r.Id
	pRMWSet.Instance = instance
	pRMWSet.Ballot = ballot
	pRMWSet.Command = r.instanceSpace[instance].cmds
	pRMWSet.Payload = r.data[int(pRMWSet.Command[0].K)]
	args := &pRMWSet

	n := r.N - 1
	q := r.Id

	for sent := 0; sent < n; {
		q = (q + 1) % int32(r.N)
		if q == r.Id {
			break
		}
		if !r.Alive[q] {
			continue
		}
		sent++
		r.SendMsg(q, r.rmwSetRPC, args)
	}
}

func (r *Replica) handleRMWSet(rmwSet *pineappleproto.RMWSet) {
	inst := r.instanceSpace[rmwSet.Instance]

	var rmwSetReply *pineappleproto.RMWSetReply

	if inst == nil {
		if rmwSet.Ballot < r.defaultBallot {
			panic("outdated ballot received")
		} else {
			r.instanceSpace[rmwSet.Instance] = &Instance{
				cmds:   rmwSet.Command,
				ballot: rmwSet.Ballot,
				status: ACCEPTED,
				lb:     nil,
			}
			rmwSetReply = &pineappleproto.RMWSetReply{Instance: rmwSet.Instance, OK: TRUE, Ballot: r.defaultBallot}
		}
	} else if inst.ballot > rmwSet.Ballot {
		panic("outdated ballot received")
	} else if inst.ballot < rmwSet.Ballot {
		inst.cmds = rmwSet.Command
		inst.ballot = rmwSet.Ballot
		inst.status = ACCEPTED
		rmwSetReply = &pineappleproto.RMWSetReply{Instance: rmwSet.Instance, OK: TRUE, Ballot: r.defaultBallot}
	} else {
		// reordered ACCEPT
		r.instanceSpace[rmwSet.Instance].cmds = rmwSet.Command
		if r.instanceSpace[rmwSet.Instance].status != COMMITTED {
			r.instanceSpace[rmwSet.Instance].status = ACCEPTED
		}
		rmwSetReply = &pineappleproto.RMWSetReply{Instance: rmwSet.Instance, OK: TRUE, Ballot: r.defaultBallot}
	}
	inst.receivedRMW = rmwSet.Payload // store received object in instance space

	r.replyRMWSet(rmwSet.LeaderId, rmwSetReply)
}

// Response handler for Set request on nodes
func (r *Replica) handleRMWSetReply(rmwSetReply *pineappleproto.RMWSetReply) {
	inst := r.instanceSpace[rmwSetReply.Instance]

	inst.lb.rmwSetOKs++

	// Wait for a majority of acknowledgements
	if inst.lb.rmwSetOKs+1 > r.N>>1 {
		if inst.lb.clientProposals != nil && r.Dreply && !inst.lb.completed {
			propreply := &genericsmrproto.ProposeReplyTS{
				OK:        TRUE,
				CommandId: inst.lb.clientProposals[0].CommandId,
				Value:     state.NIL,
				Timestamp: inst.lb.clientProposals[0].Timestamp}
			r.ReplyProposeTS(propreply, inst.lb.clientProposals[0].Reply)
			r.bcastCommit(rmwSetReply.Instance, rmwSetReply.Ballot, inst.cmds)
			inst.lb.completed = true
		}
	}

}

var pc pineappleproto.Commit
var pcs pineappleproto.CommitShort

func (r *Replica) bcastCommit(instance int32, ballot int32, command []state.Command) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("Commit bcast failed:", err)
		}
	}()
	pc.LeaderId = r.Id
	pc.Instance = instance
	pc.Ballot = ballot
	pc.Command = command
	args := &pc
	pcs.LeaderId = r.Id
	pcs.Instance = instance
	pcs.Ballot = ballot
	pcs.Count = int32(len(command))
	argsShort := &pcs

	//args := &paxosproto.Commit{r.Id, instance, command}

	n := r.N - 1
	q := r.Id
	sent := 0

	for sent < n {
		q = (q + 1) % int32(r.N)
		if q == r.Id {
			break
		}
		if !r.Alive[q] {
			continue
		}
		sent++
		r.SendMsg(q, r.commitShortRPC, argsShort)
	}
	if q != r.Id {
		for sent < r.N-1 {
			q = (q + 1) % int32(r.N)
			if q == r.Id {
				break
			}
			if !r.Alive[q] {
				continue
			}
			sent++
			r.SendMsg(q, r.commitRPC, args)
		}
	}
}

func (r *Replica) handleCommit(commit *pineappleproto.Commit) {
	inst := r.instanceSpace[commit.Instance]

	if inst == nil {
		r.instanceSpace[commit.Instance] = &Instance{
			cmds:   commit.Command,
			ballot: commit.Ballot,
			status: COMMITTED,
			lb:     nil,
		}
	} else {
		r.instanceSpace[commit.Instance].cmds = commit.Command
		r.instanceSpace[commit.Instance].status = COMMITTED
		r.instanceSpace[commit.Instance].ballot = commit.Ballot
		if inst.lb != nil && inst.lb.clientProposals != nil {
			for i := 0; i < len(inst.lb.clientProposals); i++ {
				r.ProposeChan <- inst.lb.clientProposals[i]
			}
			inst.lb.clientProposals = nil
		}
	}

	r.updateCommittedUpTo()
	r.recordInstanceMetadata(r.instanceSpace[commit.Instance])
	r.recordCommands(commit.Command)
}

func (r *Replica) handleCommitShort(commit *pineappleproto.CommitShort) {
	inst := r.instanceSpace[commit.Instance]

	if inst == nil {
		r.instanceSpace[commit.Instance] = &Instance{
			cmds:         nil,
			receivedData: nil,
			ballot:       commit.Ballot,
			status:       COMMITTED,
			lb:           nil,
		}
	} else {
		r.instanceSpace[commit.Instance].status = COMMITTED
		r.instanceSpace[commit.Instance].ballot = commit.Ballot
		if inst.lb != nil && inst.lb.clientProposals != nil {
			for i := 0; i < len(inst.lb.clientProposals); i++ {
				r.ProposeChan <- inst.lb.clientProposals[i]
			}
			inst.lb.clientProposals = nil
		}
	}

	r.updateCommittedUpTo()

	r.recordInstanceMetadata(r.instanceSpace[commit.Instance])
}

func (r *Replica) handlePropose(propose *genericsmr.Propose) {
	/*
		if !r.IsLeader {
			preply := &genericsmrproto.ProposeReplyTS{TRUE, -1, state.NIL, 0}
			r.ReplyProposeTS(preply, propose.Reply)
			return
		}
	*/
	for r.instanceSpace[r.crtInstance] != nil {
		r.crtInstance++
	}

	instNo := r.crtInstance

	cmds := make([]state.Command, 1)
	proposals := make([]*genericsmr.Propose, 1)
	key := int(propose.Command.K)
	cmds[0] = propose.Command
	proposals[0] = propose

	// ABD
	r.instanceSpace[instNo] = &Instance{
		cmds:   cmds,
		ballot: 0,
		status: PREPARING,
		lb:     &LeaderBookkeeping{clientProposals: proposals, getDone: false, completed: false},
	}

	// Use Paxos if operation is not Read / Write
	if propose.Command.Op != state.PUT && propose.Command.Op != state.GET {
		r.instanceSpace[instNo] = &Instance{
			cmds:   cmds,
			ballot: 0,
			status: PREPARING,
			lb:     &LeaderBookkeeping{clientProposals: proposals, completed: false},
		}
		r.bcastRMWGet(instNo, 0, cmds)
	} else { // use ABD
		r.data[key] = pineappleproto.Payload{
			Tag:   pineappleproto.Tag{Timestamp: int(propose.Timestamp), ID: int(r.Id)},
			Value: int(propose.Command.V),
		}

		// Construct the pineapple payload from proposal data
		if propose.Command.Op == state.PUT { // write operation
			r.bcastGet(instNo, true, key)
		} else if propose.Command.Op == state.GET { // read operation
			r.bcastGet(instNo, false, key)
		}
	}
}

func (r *Replica) executeCommands() {
	i := int32(0)
	for !r.Shutdown {
		executed := false

		for i <= r.committedUpTo {
			if r.instanceSpace[i].cmds != nil {
				inst := r.instanceSpace[i]
				for j := 0; j < len(inst.cmds); j++ {
					key := int(inst.cmds[0].K)
					if r.isLargerTag(r.data[key].Tag, inst.receivedRMW.Tag) {
						r.data[key] = inst.receivedRMW
					}
				}
				i++
				executed = true
			} else {
				break
			}
		}

		if !executed {
			time.Sleep(CLOCK)
		}
	}

}

var clockChan chan bool

func (r *Replica) makeUniqueBallot(ballot int32) int32 {
	return (ballot << 4) | r.Id
}

func (r *Replica) updateCommittedUpTo() {
	for r.instanceSpace[r.committedUpTo+1] != nil &&
		r.instanceSpace[r.committedUpTo+1].status == COMMITTED {
		r.committedUpTo++
	}
}

// append a log entry to stable storage
func (r *Replica) recordInstanceMetadata(inst *Instance) {
	if !r.Durable {
		return
	}

	var b [5]byte
	binary.LittleEndian.PutUint32(b[0:4], uint32(inst.ballot))
	b[4] = byte(inst.status)
	r.StableStore.Write(b[:])
}

// write a sequence of commands to stable storage
func (r *Replica) recordCommands(cmds []state.Command) {
	if !r.Durable {
		return
	}

	if cmds == nil {
		return
	}
	for i := 0; i < len(cmds); i++ {
		cmds[i].Marshal(io.Writer(r.StableStore))
	}
}

// sync with the stable store
func (r *Replica) sync() {
	if !r.Durable {
		return
	}

	r.StableStore.Sync()
}

func (r *Replica) clock() {
	for !r.Shutdown {
		time.Sleep(CLOCK)
		clockChan <- true
	}
}

// Run main processing loop
func (r *Replica) Run() {
	r.ConnectToPeers()

	log.Println("Waiting for client connections")

	go r.WaitForClientConnections()

	clockChan = make(chan bool, 1)
	go r.clock()

	// We don't directly access r.ProposeChan, because we want to do pipelining periodically,
	// so we introduce a channel pointer: onOffProposChan:
	onOffProposeChan := r.ProposeChan

	for !r.Shutdown {

		select {
		case <-clockChan:
			// activate the new proposals channel
			onOffProposeChan = r.ProposeChan
			break
		case setS := <-r.setChan:
			set := setS.(*pineappleproto.Set)
			//got a Write message
			r.handleSet(set)
			break
		case getS := <-r.getChan:
			get := getS.(*pineappleproto.Get)
			//got a Read message
			r.handleGet(get)
			break
		case setReplyS := <-r.setReplyChan:
			setReply := setReplyS.(*pineappleproto.SetReply)
			//got a Write reply
			r.handleSetReply(setReply)
			break
		case getReplyS := <-r.getReplyChan:
			getReply := getReplyS.(*pineappleproto.GetReply)
			//got a Read reply
			r.handleGetReply(getReply)
			break
		case propose := <-onOffProposeChan:
			//got a Propose from a client
			// Handle proposal: single read-write object goes to ABD, multi read/write or RMW goes to Paxos
			r.handlePropose(propose)
			// deactivate the new proposals channel to prioritize the handling of protocol messages
			onOffProposeChan = nil
			break
		case prepareS := <-r.prepareChan:
			prepare := prepareS.(*pineappleproto.Prepare)
			//got a Prepare message
			r.handlePrepare(prepare)
			break
		case prepareReplyS := <-r.prepareReplyChan:
			prepareReply := prepareReplyS.(*pineappleproto.PrepareReply)
			//got a Prepare reply
			r.handlePrepareReply(prepareReply)
			break
		case rmwGetS := <-r.rmwGetChan:
			rmwGet := rmwGetS.(*pineappleproto.RMWGet)
			//got an RMWGet message
			r.handleRMWGet(rmwGet)
			break
		case rmwGetReplyS := <-r.rmwGetReplyChan:
			rmwGetReply := rmwGetReplyS.(*pineappleproto.RMWGetReply)
			//got an RMWGet reply
			r.handleRMWGetReply(rmwGetReply)
			break
		case rmwSetS := <-r.rmwSetChan:
			rmwSet := rmwSetS.(*pineappleproto.RMWSet)
			//got an Accept message
			r.handleRMWSet(rmwSet)
			break
		case rmwSetReplyS := <-r.rmwSetReplyChan:
			rmwSetReply := rmwSetReplyS.(*pineappleproto.RMWSetReply)
			//got an Accept reply
			r.handleRMWSetReply(rmwSetReply)
			break
		case commitS := <-r.commitChan:
			commit := commitS.(*pineappleproto.Commit)
			//got a Commit message
			log.Printf("Received Commit from replica %d, for instance %d\n", commit.LeaderId, commit.Instance)
			r.handleCommit(commit)
			break
		case commitS := <-r.commitShortChan:
			commit := commitS.(*pineappleproto.CommitShort)
			//got a Commit message
			log.Printf("Received Commit from replica %d, for instance %d\n", commit.LeaderId, commit.Instance)
			r.handleCommitShort(commit)
			break
		}
	}
}

/* RPC to be called by master */
func (r *Replica) BeTheLeader(args *genericsmrproto.BeTheLeaderArgs, reply *genericsmrproto.BeTheLeaderReply) error {
	r.IsLeader = true
	return nil
}
